{"ast":null,"code":"import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\nfunction hilbert2D(center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3) {\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]];\n\n  // Recurse iterations\n  if (0 <= --iterations) {\n    return [...hilbert2D(vec[0], half, iterations, v0, v3, v2, v1), ...hilbert2D(vec[1], half, iterations, v0, v1, v2, v3), ...hilbert2D(vec[2], half, iterations, v0, v1, v2, v3), ...hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)];\n  }\n\n  // Return complete Hilbert Curve.\n  return vec;\n}\n\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link https://openprocessing.org/user/5654\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\nfunction hilbert3D(center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7) {\n  // Default Vars\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];\n\n  // Recurse iterations\n  if (--iterations >= 0) {\n    return [...hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1), ...hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3), ...hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3), ...hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5), ...hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5), ...hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7), ...hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7), ...hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)];\n  }\n\n  // Return complete Hilbert Curve.\n  return vec;\n}\n\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\nfunction gosper(size = 1) {\n  function fractalize(config) {\n    let output;\n    let input = config.axiom;\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j];\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n      input = output;\n    }\n    return output;\n  }\n  function toPoints(config) {\n    let currX = 0,\n      currY = 0;\n    let angle = 0;\n    const path = [0, 0, 0];\n    const fractal = config.fractal;\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i];\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n    return path;\n  }\n\n  //\n\n  const gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  const points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n  });\n  return points;\n}\nexport { hilbert2D, hilbert3D, gosper };","map":{"version":3,"names":["Vector3","hilbert2D","center","size","iterations","v0","v1","v2","v3","half","vec_s","x","y","z","vec","hilbert3D","v4","v5","v6","v7","gosper","fractalize","config","output","input","axiom","i","il","steps","j","jl","length","char","rules","toPoints","currX","currY","angle","path","fractal","l","Math","cos","sin","push","A","B","points","PI"],"sources":["C:/Users/user/node_modules/three/examples/jsm/utils/GeometryUtils.js"],"sourcesContent":["import { Vector3 } from 'three';\n\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\nfunction hilbert2D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3 ) {\n\n\tconst half = size / 2;\n\n\tconst vec_s = [\n\t\tnew Vector3( center.x - half, center.y, center.z - half ),\n\t\tnew Vector3( center.x - half, center.y, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y, center.z - half )\n\t];\n\n\tconst vec = [\n\t\tvec_s[ v0 ],\n\t\tvec_s[ v1 ],\n\t\tvec_s[ v2 ],\n\t\tvec_s[ v3 ]\n\t];\n\n\t// Recurse iterations\n\tif ( 0 <= -- iterations ) {\n\n\t\treturn [\n\t\t\t...hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ),\n\t\t\t...hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ),\n\t\t\t...hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ),\n\t\t\t...hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 )\n\t\t];\n\n\t}\n\n\t// Return complete Hilbert Curve.\n\treturn vec;\n\n}\n\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link https://openprocessing.org/user/5654\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\nfunction hilbert3D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7 ) {\n\n\t// Default Vars\n\tconst half = size / 2;\n\n\tconst vec_s = [\n\t\tnew Vector3( center.x - half, center.y + half, center.z - half ),\n\t\tnew Vector3( center.x - half, center.y + half, center.z + half ),\n\t\tnew Vector3( center.x - half, center.y - half, center.z + half ),\n\t\tnew Vector3( center.x - half, center.y - half, center.z - half ),\n\t\tnew Vector3( center.x + half, center.y - half, center.z - half ),\n\t\tnew Vector3( center.x + half, center.y - half, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y + half, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y + half, center.z - half )\n\t];\n\n\tconst vec = [\n\t\tvec_s[ v0 ],\n\t\tvec_s[ v1 ],\n\t\tvec_s[ v2 ],\n\t\tvec_s[ v3 ],\n\t\tvec_s[ v4 ],\n\t\tvec_s[ v5 ],\n\t\tvec_s[ v6 ],\n\t\tvec_s[ v7 ]\n\t];\n\n\t// Recurse iterations\n\tif ( -- iterations >= 0 ) {\n\n\t\treturn [\n\t\t\t...hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ),\n\t\t\t...hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),\n\t\t\t...hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),\n\t\t\t...hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),\n\t\t\t...hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),\n\t\t\t...hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),\n\t\t\t...hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),\n\t\t\t...hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 )\n\t\t];\n\n\t}\n\n\t// Return complete Hilbert Curve.\n\treturn vec;\n\n}\n\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\nfunction gosper( size = 1 ) {\n\n\tfunction fractalize( config ) {\n\n\t\tlet output;\n\t\tlet input = config.axiom;\n\n\t\tfor ( let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i ++ : i -- ) {\n\n\t\t\toutput = '';\n\n\t\t\tfor ( let j = 0, jl = input.length; j < jl; j ++ ) {\n\n\t\t\t\tconst char = input[ j ];\n\n\t\t\t\tif ( char in config.rules ) {\n\n\t\t\t\t\toutput += config.rules[ char ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\toutput += char;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tinput = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tfunction toPoints( config ) {\n\n\t\tlet currX = 0, currY = 0;\n\t\tlet angle = 0;\n\t\tconst path = [ 0, 0, 0 ];\n\t\tconst fractal = config.fractal;\n\n\t\tfor ( let i = 0, l = fractal.length; i < l; i ++ ) {\n\n\t\t\tconst char = fractal[ i ];\n\n\t\t\tif ( char === '+' ) {\n\n\t\t\t\tangle += config.angle;\n\n\t\t\t} else if ( char === '-' ) {\n\n\t\t\t\tangle -= config.angle;\n\n\t\t\t} else if ( char === 'F' ) {\n\n\t\t\t\tcurrX += config.size * Math.cos( angle );\n\t\t\t\tcurrY += - config.size * Math.sin( angle );\n\t\t\t\tpath.push( currX, currY, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn path;\n\n\t}\n\n\t//\n\n\tconst gosper = fractalize( {\n\t\taxiom: 'A',\n\t\tsteps: 4,\n\t\trules: {\n\t\t\tA: 'A+BF++BF-FA--FAFA-BF+',\n\t\t\tB: '-FA+BFBF++BF+FA--FA-B'\n\t\t}\n\t} );\n\n\tconst points = toPoints( {\n\t\tfractal: gosper,\n\t\tsize: size,\n\t\tangle: Math.PI / 3 // 60 degrees\n\t} );\n\n\treturn points;\n\n}\n\n\n\nexport {\n\thilbert2D,\n\thilbert3D,\n\tgosper,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}